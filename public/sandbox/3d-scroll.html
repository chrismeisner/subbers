<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D TorusKnot (Partial Width Resize + Locked Height)</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
	/*
	  We rely on Tailwind classes plus a small custom fade-in sequence:
	  1) body.fade-in => starts with opacity-0.
	  2) We add .loaded => transitions to opacity-100 over 0.7s.
	*/
	body.fade-in {
	  @apply opacity-0 transition-opacity duration-700 ease-in-out;
	}
	body.fade-in.loaded {
	  @apply opacity-100;
	}
  </style>
</head>

<body class="m-0 h-[200vh] relative fade-in" onload="setRandomColorsAndInit()">
  <!-- Container for the Three.js canvas -->
  <div id="canvas-container" class="fixed top-0 left-0 w-full h-full overflow-hidden -z-10"></div>

  <!-- Content to create scroll space -->
  <div class="relative pt-[100vh] text-center text-2xl">
	<p>Scroll to rotate the TorusKnot!</p>
	<p class="mt-8">Refresh to see random background & knot colors (height remains locked).</p>
	<p class="mt-2 text-base text-gray-600">
	  Rotate your device or change browser width to see partial resize. 
	  Height won't change, so no vertical jump on mobile UI changes.
	</p>
  </div>

  <!-- Three.js and GSAP + ScrollTrigger from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/ScrollTrigger.min.js"></script>

  <script>
	// ------------------------------------------------------------------------
	// 1. HELPER: Generate a random #RRGGBB color string
	// ------------------------------------------------------------------------
	function getRandomHexColor() {
	  return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
	}

	// ------------------------------------------------------------------------
	// 2. GLOBALS
	// ------------------------------------------------------------------------
	let scene, camera, renderer, torusKnot;
	let chosenKnotColor;
	let hasRenderedFirstFrame = false; // For fade-in logic

	// We'll lock the original height at load
	let originalHeight;

	// ------------------------------------------------------------------------
	// 3. SET RANDOM COLORS & INIT (CALLED ON BODY ONLOAD)
	// ------------------------------------------------------------------------
	function setRandomColorsAndInit() {
	  // Random background color
	  const randomBGColor = getRandomHexColor();
	  document.body.style.backgroundColor = randomBGColor;

	  // Random knot color
	  chosenKnotColor = getRandomHexColor();

	  console.log("Random BG Color:", randomBGColor);
	  console.log("Random Knot Color:", chosenKnotColor);

	  // Store the initial height (locking it)
	  originalHeight = window.innerHeight;

	  // Initialize the 3D scene now that we have our colors
	  init3D();
	}

	// ------------------------------------------------------------------------
	// 4. INIT THREE.JS SCENE
	// ------------------------------------------------------------------------
	function init3D() {
	  scene = new THREE.Scene();

	  camera = new THREE.PerspectiveCamera(
		60,
		window.innerWidth / originalHeight, // we'll lock the height
		0.1,
		1000
	  );
	  camera.position.set(0, 0, 3);

	  // Create the renderer at the initial window size (width, locked height)
	  renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
	  renderer.setSize(window.innerWidth, originalHeight);
	  document.getElementById('canvas-container').appendChild(renderer.domElement);

	  // Basic lighting
	  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
	  scene.add(ambientLight);

	  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
	  directionalLight.position.set(5, 5, 5);
	  scene.add(directionalLight);

	  // --------------------------------------------------------------------
	  //    TORUS KNOT GEOMETRY (COMPLEX)
	  // --------------------------------------------------------------------
	  //  radius=0.5, tube=0.225, tubularSegments=256, radialSegments=64, p=2, q=3
	  const geometry = new THREE.TorusKnotGeometry(0.5, 0.225, 256, 64, 2, 3);

	  // --------------------------------------------------------------------
	  //    MATERIAL
	  // --------------------------------------------------------------------
	  const material = new THREE.MeshLambertMaterial({
		color: chosenKnotColor
	  });

	  // Create the mesh
	  torusKnot = new THREE.Mesh(geometry, material);
	  scene.add(torusKnot);

	  // Start the render loop
	  animate();

	  // Setup scroll-triggered rotation
	  initScrollTrigger();

	  // Now we can listen for width-only resize
	  window.addEventListener('resize', onWindowResize);
	}

	// ------------------------------------------------------------------------
	// 5. RENDER LOOP (FADE-IN ON FIRST FRAME)
	// ------------------------------------------------------------------------
	function animate() {
	  requestAnimationFrame(animate);

	  // On the first rendered frame, remove fade-in's initial opacity
	  if (!hasRenderedFirstFrame) {
		document.body.classList.add('loaded');
		hasRenderedFirstFrame = true;
	  }

	  renderer.render(scene, camera);
	}

	// ------------------------------------------------------------------------
	// 6. SCROLLTRIGGER FOR ROTATION
	// ------------------------------------------------------------------------
	function initScrollTrigger() {
	  gsap.registerPlugin(ScrollTrigger);

	  gsap.to(torusKnot.rotation, {
		x: 2 * Math.PI,
		y: 2 * Math.PI,
		scrollTrigger: {
		  trigger: document.body,
		  start: 'top top',
		  end: 'bottom top',
		  scrub: 1
		}
	  });
	}

	// ------------------------------------------------------------------------
	// 7. HANDLE RESIZE (width-only)
	// ------------------------------------------------------------------------
	function onWindowResize() {
	  const newWidth = window.innerWidth;

	  // Keep the renderer's height fixed at originalHeight
	  renderer.setSize(newWidth, originalHeight);

	  // Update the camera's aspect ratio using originalHeight
	  camera.aspect = newWidth / originalHeight;
	  camera.updateProjectionMatrix();
	}
  </script>
</body>
</html>
